{
    "background": "A restaurant offers two types of meal combos, original and experimental. Both create food and wrapping waste while requiring different cooking times.",
    "problem_type": "LP",
    "parameters": [
        {
            "definition": "Food waste units generated by the original meal",
            "symbol": "WasteFoodOriginal",
            "value": 20,
            "shape": [],
            "code": "WasteFoodOriginal = data[\"WasteFoodOriginal\"] # scalar parameter"
        },
        {
            "definition": "Wrapping waste units generated by the original meal",
            "symbol": "WasteWrapOriginal",
            "value": 45,
            "shape": [],
            "code": "WasteWrapOriginal = data[\"WasteWrapOriginal\"] # scalar parameter"
        },
        {
            "definition": "Cooking time for the original meal",
            "symbol": "TimeOriginal",
            "value": 10,
            "shape": [],
            "code": "TimeOriginal = data[\"TimeOriginal\"] # scalar parameter"
        },
        {
            "definition": "Food waste units generated by the experimental meal",
            "symbol": "WasteFoodExperimental",
            "value": 25,
            "shape": [],
            "code": "WasteFoodExperimental = data[\"WasteFoodExperimental\"] # scalar parameter"
        },
        {
            "definition": "Wrapping waste units generated by the experimental meal",
            "symbol": "WasteWrapExperimental",
            "value": 35,
            "shape": [],
            "code": "WasteWrapExperimental = data[\"WasteWrapExperimental\"] # scalar parameter"
        },
        {
            "definition": "Cooking time for the experimental meal",
            "symbol": "TimeExperimental",
            "value": 15,
            "shape": [],
            "code": "TimeExperimental = data[\"TimeExperimental\"] # scalar parameter"
        },
        {
            "definition": "Maximum allowable wrapping waste units",
            "symbol": "MaxWrapWaste",
            "value": 900,
            "shape": [],
            "code": "MaxWrapWaste = data[\"MaxWrapWaste\"] # scalar parameter"
        },
        {
            "definition": "Maximum allowable food waste units",
            "symbol": "MaxFoodWaste",
            "value": 800,
            "shape": [],
            "code": "MaxFoodWaste = data[\"MaxFoodWaste\"] # scalar parameter"
        }
    ],
    "constraints": [
        {
            "description": "The number of original meals prepared must be non-negative.",
            "status": "coded",
            "formulation": "\\textup{OriginalMealCount} \\geq 0",
            "related_variables": [
                "OriginalMealCount"
            ],
            "related_parameters": [],
            "code": "# No additional code needed since the variable \"OriginalMealCount\" is non-negative by default (continuous variables in Gurobi are non-negative unless otherwise specified)."
        },
        {
            "description": "The number of experimental meals prepared by the restaurant must be non-negative.",
            "status": "coded",
            "formulation": "\\textup{ExperimentalMealCount} \\geq 0",
            "related_variables": [
                "ExperimentalMealCount"
            ],
            "related_parameters": [],
            "code": "# No additional code needed since the variable \"ExperimentalMealCount\" is already defined with non-negativity guaranteed by Gurobi's default behavior for continuous variables (lower bound is 0)."
        },
        {
            "description": "The total food waste generated by original and experimental meals must be at most the maximum allowable food waste.",
            "status": "coded",
            "formulation": "(\\textup{OriginalMealCount} \\times \\textup{WasteFoodOriginal}) + (\\textup{ExperimentalMealCount} \\times \\textup{WasteFoodExperimental}) \\leq \\textup{MaxFoodWaste}",
            "related_variables": [
                "OriginalMealCount",
                "ExperimentalMealCount"
            ],
            "related_parameters": [
                "WasteFoodOriginal",
                "WasteFoodExperimental",
                "MaxFoodWaste"
            ],
            "code": "# Add food waste constraint\nmodel.addConstr(\n    (OriginalMealCount * WasteFoodOriginal) + (ExperimentalMealCount * WasteFoodExperimental) <= MaxFoodWaste,\n    name=\"food_waste_limit\"\n)"
        },
        {
            "description": "The wrapping waste from original meals plus the wrapping waste from experimental meals must not exceed the maximum allowable wrapping waste.",
            "status": "coded",
            "formulation": "\\\\textup{OriginalMealCount} \\\\times \\\\textup{WasteWrapOriginal} + \\\\textup{ExperimentalMealCount} \\\\times \\\\textup{WasteWrapExperimental} \\\\leq \\\\textup{MaxWrapWaste}",
            "related_variables": [
                "OriginalMealCount",
                "ExperimentalMealCount"
            ],
            "related_parameters": [
                "WasteWrapOriginal",
                "WasteWrapExperimental",
                "MaxWrapWaste"
            ],
            "code": "# Add constraint to limit the wrapping waste\nmodel.addConstr(OriginalMealCount * WasteWrapOriginal + ExperimentalMealCount * WasteWrapExperimental <= MaxWrapWaste, name=\"wrap_waste_limit\")"
        },
        {
            "description": "Total wrapping waste must not exceed the maximum allowable wrapping waste.",
            "status": "coded",
            "formulation": "\\textup{WasteWrapOriginal} \\\\times \\\\textup{OriginalMealCount} + \\textup{WasteWrapExperimental} \\\\times \\\\textup{ExperimentalMealCount} \\\\leq \\\\textup{MaxWrapWaste}",
            "related_variables": [
                "OriginalMealCount",
                "ExperimentalMealCount"
            ],
            "related_parameters": [
                "WasteWrapOriginal",
                "WasteWrapExperimental",
                "MaxWrapWaste"
            ],
            "code": "# Add wrapping waste constraint\nmodel.addConstr(\n    OriginalMealCount * WasteWrapOriginal + ExperimentalMealCount * WasteWrapExperimental <= MaxWrapWaste,\n    name=\"wrapping_waste_constraint\"\n)"
        },
        {
            "description": "Total food waste must not exceed the maximum allowable food waste.",
            "status": "coded",
            "formulation": "\\textup{WasteFoodOriginal} \\\\times \\\\textup{OriginalMealCount} + \\textup{WasteFoodExperimental} \\\\times \\\\textup{ExperimentalMealCount} \\\\leq \\\\textup{MaxFoodWaste}",
            "related_variables": [
                "OriginalMealCount",
                "ExperimentalMealCount"
            ],
            "related_parameters": [
                "WasteFoodOriginal",
                "WasteFoodExperimental",
                "MaxFoodWaste"
            ],
            "code": "# Add total food waste constraint\nmodel.addConstr(\n    WasteFoodOriginal * OriginalMealCount + WasteFoodExperimental * ExperimentalMealCount <= MaxFoodWaste,\n    name=\"food_waste_constraint\"\n)"
        }
    ],
    "variables": [
        {
            "definition": "The number of original meals prepared by the restaurant.",
            "symbol": "OriginalMealCount",
            "shape": [],
            "status": "coded",
            "code": "OriginalMealCount = model.addVar(vtype=gp.GRB.CONTINUOUS, name=\"OriginalMealCount\")"
        },
        {
            "definition": "The number of experimental meals prepared by the restaurant.",
            "symbol": "ExperimentalMealCount",
            "shape": [],
            "status": "coded",
            "code": "ExperimentalMealCount = model.addVar(vtype=gp.GRB.CONTINUOUS, name=\"ExperimentalMealCount\")"
        }
    ],
    "objective": [
        {
            "description": "Minimize the total cooking time for meals pushed by the waiting staff.",
            "status": "coded",
            "formulation": "\\textup{Minimize:} \\quad \\textup{TimeOriginal} \\\\times \\\\textup{OriginalMealCount} + \\textup{TimeExperimental} \\\\times \\\\textup{ExperimentalMealCount}",
            "related_variables": [
                "OriginalMealCount",
                "ExperimentalMealCount"
            ],
            "related_parameters": [
                "TimeOriginal",
                "TimeExperimental"
            ],
            "code": "# Set objective\nmodel.setObjective(TimeOriginal * OriginalMealCount + TimeExperimental * ExperimentalMealCount, gp.GRB.MINIMIZE)"
        }
    ],
    "solution_status": "solved",
    "solver_output_status": 2,
    "error_message": null,
    "obj_val": 0.0,
    "log_path": "logs/log_20250413180202_nl4opt_prob_243/",
    "problem_path": "data/nl4opt/prob_243/",
    "code": "import json\nimport numpy as np\nimport math\n\nimport gurobipy as gp\n\n# Define model\nmodel = gp.Model('model')\n\nwith open(\"data/nl4opt/prob_243/data.json\", \"r\") as f:\n    data = json.load(f)\n\nWasteFoodOriginal = data[\"WasteFoodOriginal\"] # scalar parameter\nWasteWrapOriginal = data[\"WasteWrapOriginal\"] # scalar parameter\nTimeOriginal = data[\"TimeOriginal\"] # scalar parameter\nWasteFoodExperimental = data[\"WasteFoodExperimental\"] # scalar parameter\nWasteWrapExperimental = data[\"WasteWrapExperimental\"] # scalar parameter\nTimeExperimental = data[\"TimeExperimental\"] # scalar parameter\nMaxWrapWaste = data[\"MaxWrapWaste\"] # scalar parameter\nMaxFoodWaste = data[\"MaxFoodWaste\"] # scalar parameter\nOriginalMealCount = model.addVar(vtype=gp.GRB.CONTINUOUS, name=\"OriginalMealCount\")\nExperimentalMealCount = model.addVar(vtype=gp.GRB.CONTINUOUS, name=\"ExperimentalMealCount\")\n\n# No additional code needed since the variable \"OriginalMealCount\" is non-negative by default (continuous variables in Gurobi are non-negative unless otherwise specified).\n\n# No additional code needed since the variable \"ExperimentalMealCount\" is already defined with non-negativity guaranteed by Gurobi's default behavior for continuous variables (lower bound is 0).\n\n# Add food waste constraint\nmodel.addConstr(\n    (OriginalMealCount * WasteFoodOriginal) + (ExperimentalMealCount * WasteFoodExperimental) <= MaxFoodWaste,\n    name=\"food_waste_limit\"\n)\n\n# Add constraint to limit the wrapping waste\nmodel.addConstr(OriginalMealCount * WasteWrapOriginal + ExperimentalMealCount * WasteWrapExperimental <= MaxWrapWaste, name=\"wrap_waste_limit\")\n\n# Add wrapping waste constraint\nmodel.addConstr(\n    OriginalMealCount * WasteWrapOriginal + ExperimentalMealCount * WasteWrapExperimental <= MaxWrapWaste,\n    name=\"wrapping_waste_constraint\"\n)\n\n# Add total food waste constraint\nmodel.addConstr(\n    WasteFoodOriginal * OriginalMealCount + WasteFoodExperimental * ExperimentalMealCount <= MaxFoodWaste,\n    name=\"food_waste_constraint\"\n)\n\n# Set objective\nmodel.setObjective(TimeOriginal * OriginalMealCount + TimeExperimental * ExperimentalMealCount, gp.GRB.MINIMIZE)\n\n# Optimize model\nmodel.optimize()\n\n\n# Get model status\nstatus = model.status\n\nobj_val = None\n# check whether the model is infeasible, has infinite solutions, or has an optimal solution\nif status == gp.GRB.INFEASIBLE:\n    obj_val = \"infeasible\"\nelif status == gp.GRB.INF_OR_UNBD:\n    obj_val = \"infeasible or unbounded\"\nelif status == gp.GRB.UNBOUNDED:\n    obj_val = \"unbounded\"\nelif status == gp.GRB.OPTIMAL:\n    obj_val = model.objVal\n"
}